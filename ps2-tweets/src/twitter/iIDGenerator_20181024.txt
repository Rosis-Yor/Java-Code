package twitter;


import java.util.Random;
import java.io.File;
import java.time.Instant;
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

/*
 * This class Produces random ID between 0 < id <50
 * and stores it in a HashSet 
 * */
public class IDGenerator {
    
    private final static int CAPACITY = 8;
    private static final Set<Long> reg = new HashSet<Long>((CAPACITY), 1.0f);
    private long id ;
    private enum Direction {LEFT, RIGHT};
    
    // 
    IDGenerator(boolean bo) {        
        if (bo) makeIDfast();
        else makeID();
    }
    
    IDGenerator () {        
       makeID();
    }
   
    
    /*
     * A straightforward way to obtain an unique number between 0 < id < CAPACITY
     * which could be used for a reasonably small / short sets, up to CAPACITY / 2;
     * Otherwise it becomes inefficient with regard to the time.
     * */
    private void makeID () {
       
            while(true) {
                Instant toSeed = Instant.now();
                long seedRandom = toSeed.getEpochSecond();
                Random numSpitter = new Random(seedRandom);
                long idMould = numSpitter.nextLong();
                long idCandidate = Math.abs( idMould % CAPACITY);
                
                    if (!reg.contains(idCandidate)) {                        
                        reg.add(idCandidate);
                        id = idCandidate;
                        return ;
                    }
                }           
            }
    
    /*
     * A method to efficienly distribute the numbers (IDs) over the whole
     * capacity of the Registry
     * */
    
    private void makeIDfast ()  {         
        while(true) {
            checkSize();
            Instant toSeed = Instant.now();
            long seedRandom = toSeed.getEpochSecond();
            Random numSpitter = new Random(seedRandom);
            long idMould = numSpitter.nextLong();
            long idCandidate = Math.abs( idMould % CAPACITY);
            if (idCandidate == 0) idCandidate = (long) CAPACITY;
             
            if (!reg.contains(idCandidate) ) {
               addCandidate(idCandidate);
               return;
            } 
           
            else {
                Direction iterate = Math.random() <= 0.5 ? Direction.LEFT : Direction.RIGHT;
                long idx = idCandidate;
                while (idx == idCandidate && CAPACITY - reg.size() > 2 ) {
                    switch (iterate) { 
                    case LEFT: 
                            idx = idx -2;
                           while (reg.contains(idx) && idx  > 0) {                           
                               idx--;                               
                           }
                           if (idx <= 0) {
                               iterate = Direction.RIGHT;
                               idx = idCandidate;
                               break;
                           }
                           addCandidate(idx);                          
                           break;
                    case RIGHT:
                        idx = idx + 2;
                        while (reg.contains(idx) && idx <= CAPACITY) {                           
                            idx++;                           
                        }
                        if (idx > CAPACITY) {
                            iterate = Direction.LEFT;
                            idx = idCandidate;
                            break;
                        }
                        addCandidate(idx);                       
                        break;                     
                  
                    } 
                    System.out.println(idx + " " + idCandidate);
                   // writeToFile(idx + " " + idCandidate);
                }
               
              
                 if (((CAPACITY - reg.size()) <= 3) ) {
                    if (iterate == Direction.LEFT) {
                    while (!reg.contains(idx) ) {
                        
                        idx--;
                        if(idx == 0) idx =  CAPACITY;
                    } 
                    addCandidate(idx);                   
                    }
                    else if (iterate == Direction.RIGHT) {
                        while (!reg.contains(idx) ) {
                            
                            idx++;
                            if(idx == CAPACITY) idx =  0;
                        } 
                        addCandidate(idx);                   
                        }
                    return;
                }
                return;
            }           
        }     
    }
    
    /*
     * Adds a (long) to the HashSet
     * */
    
    private void addCandidate(long idValue) {
        
        checkSize();       
        if (!reg.contains(idValue) && idValue > 0 && idValue <= CAPACITY) {
            reg.add(idValue);
         //   writeToFile( "# " + idValue + " |" + reg.size());
            id = idValue;
            return ;
        } 
        else { return; }
        }
    
    /*
     * no adding if it would exceed the CAPACITY.
     * */    
    private void checkSize() {
        
        if (reg.size() == CAPACITY) {            
            System.out.println("Registry is full");
            System.out.println("Tomorrow we will deliver more IDs.");
            return;                   
            }
    }
   
    /*
     * returns the id of the current class instance 
     * */
    public long getID () {        
        return id;
    }

    
    /*
     * returns the size of the set
     * */    
    public static int size() {
        
        return reg.size();
    }  

    private void writeToFile(String content) {
        
        try {
        String pathTo = new File(".").getCanonicalPath();    
        
        // !!!
        //Path adjustment might be necessary on other platform
        File input = new File(pathTo + "\\src\\twitter\\debug.txt");         

        // If file doesn't exists, then create it
        if (!input.exists()) {
            input.createNewFile();
        }

        FileWriter fw = new FileWriter(input, true);
        BufferedWriter bw = new BufferedWriter(fw);

        // Write in file
        bw.append(content + "\r");
        bw.close();
        return;        
        }
        catch(IOException e) {
            return;
        }
        
    }
    
    /*
     * Iterates over the set
     * */
    public static void list() {
        
        Iterator<Long> iter = reg.iterator();
        while (iter.hasNext())
        {
            System.out.println(iter.next());
        }                
    }

    public static void main(String[] args) {
        
    
        for (int i = 1; i <= 12; i++) {
        IDGenerator idTweet = new IDGenerator(true);  
    System.out.println("# " + i + "| " + idTweet.getID() + " * " + reg.size() + " || ");
    }
        /*
        for (int i = 1; i <= IDGenerator.size(); i++) {
           IDGenerator.review();
        }
        */
        
        IDGenerator.list();
    }
}
